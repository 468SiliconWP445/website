<!DOCTYPE html>
<html>
<head>
<title>Assembly to Machine Code Analysis</title>
<link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>

<h1>Assembly to Machine Code Analysis</h1>
<p><i>All multi byte hexadecimal values on this page are represented in little-endian format, where the least significant byte comes first, e.g. <code>0F 00</code> is the same as <code>0x000F</code>.</i></p>
  <br>
  <br>
<h2>Analysing a simple instruction</h2>
  <br>
<p>For example, we might have the instruction <code>mov ax, 5</code>. This directly translates to <code>B8 05 00</code> in hexadecimal or <code>10111000 00000101 00000000</code> in binary. </p>
  <br>
<h4>The opcode</h4>
<p>The opcode (operation code), <code>B8</code> (or, in binary, <code>10111000</code>), is the opcode for <code>mov ax, imm16</code>.</p>
  <br>
<p><code>mov</code> copies the data from the source (which in this case is an immediate value, 5), to the destination (in this case the <code>ax</code> 16 bit register).</p>
<p><code>ax</code>, the accumulator register, is a 16 bit register in the x86 architecture, and it is a general purpose register.</p>
<p><code>imm16</code> is an immediate 16 bit value. It is different to a value stored in memory or registers, as it is constant data embedded directly in to the instruction.</p>
  <br>
<h4>The operand</h4>
<p>The next two bytes, <code>05 00</code>, (or, in binary, <code>00000101 00000000</code>), are the immediate value that is moved into <code>ax</code>.</p>
  <br>
  <br>
<h2>Another simple set of instructions</h2>
  <br>
<p>Let's say we have the instructions</p>
<p><code>mov ax, 5</code></p>
<p><code>mov bx, 15</code></p>
<p><code>add ax, bx</code></p>
  <br>
<p>The hexadecimal for these instructions is as follows:</p>
<p><code>B8 05 00 BB 0F 00 01 D8</code></p>
  <br>
<p>Or, in binary:</p>
<p><code>10111000 00000101 00000000 10111011 00001111 00000000 00000001 11011000</code></p>
  <br>
<p>Again, <code>mov ax, 5</code> corresponds to <code>B8 05 00</code> (<code>10111000 00000101 00000000</code>), as shown before. </p>
  <br>
<p>The instruction <code>mov bx, 15</code> corresponds to BB 0F 00.</p>
<p><code>BB</code> is the opcode for <code>mov bx, imm16</code>. <code>mov bx, imm16</code> is the same as <code>mov ax, imm16</code> (which is explained above), except that the 16 bit value is moved in to the register <code>bx</code> instead of <code>ax</code>.</p>
<p><code>0F 00</code> is hexadecimal for 15, which is the immediate value that is moved in to <code>bx</code>.</p>
<p><code>01</code> is the opcode for <code>add r/m16, r16</code>, which means it adds a 16 bit register or memory operand with another 16-bit register.</p>
<p><code>D8</code> is the ModR/M byte, which specifies the source and destination registers.</p>
<p>The <code>Mod</code> field specifies whether the operand are registers or memory, the <code>Reg</code> field specifies the source register, and the <code>R/M</code> field specifies the destination register or memory operand.</p>
  <br>
<p>In binary, the hexidecimal equivalent of <code>D8</code> is <code>11011000</code>.</p>
  <br>
<p>This can be broken down in to three parts:</p>
<p>The first two bits, in this case <code>11</code>, specify the Mod (mode) field. <code>11</code> means both operands are registers (not memory).</p>
<p>The next three bits, the Reg field, in this case, has <code>011</code> as its value. <code>011</code> represents the <code>bx</code> register (the source register).</p>
<p>The last three bits, the R/M field, in this case, has <code>000</code> as its value. <code>000</code> represents the <code>ax</code> register (the destination register).</p>
  <br>
<p>This can be interpreted as <code>ax = ax + bx</code>.</p>

<table border="1">
<caption>A slightly more complex DOS program</caption>
<thead>
<tr>
  <th>Machine Code (Hex)</th>
  <th>Header 2</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>B8 05 00</code></td>
  <td><code>mov ax, 5</code></td>
</tr>
<tr>
  <td><code>BB 03 00</code></td>
  <td><code>mov bx, 3</code></td>
</tr>
<tr>
  <td><code>01 D8</code></td>
  <td><code>add ax, bx</code></td>
</tr>
<tr>
  <td><code>83 F8 08</code></td>
  <td><code>cmp ax, 8</code></td>
</tr>
<tr>
  <td><code>74 05</code></td>
  <td><code>jmp if_equal (jump 5 bytes forward)</code></td>
</tr>
<tr>
  <td><code>83 E8 02</code></td>
  <td><code>sub ax, 2</code></td>
</tr>
<tr>
  <td><code>EB 07</code></td>
  <td><code>jmp quit (jump 7 bytes forward)</code></td>
</tr>
<tr>
  <td><code>89 C1</code></td>
  <td><code>mov cx, ax</code></td>
</tr>
<tr>
  <td><code>83 E9 05</code></td>
  <td><code>sub cx, 5</code></td>
</tr>
<tr>
  <td><code>EB 00</code></td>
  <td><code>jmp quit (jump 0 bytes forward)</code></td>
</tr>
<tr>
  <td><code>B4 4C</code></td>
  <td><code>mov ah, 0x4C</code></td>
</tr>
<tr>
  <td><code>A0 20 00</code></td>
  <td><code>mov al, [exit_code] (located at address 0x0020 (20 00 in little-endian hex))</code></td>
</tr>
<tr>
  <td><code>CD 21</code></td>
  <td><code>int 0x21</code></td>
</tr>
<tr>
  <td><code>00</code></td>
  <td><code>exit code (in this case, 0)</code></td>
</tr>
</tbody>
</table>

</body>
</html>
